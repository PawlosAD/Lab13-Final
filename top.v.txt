module top
#(
    parameter DIVIDE_BY = 17
)
(
    input [7:0] sw,       // sw[3:0] = A, sw[7:4] = B
    input clk,            // 100 MHz clock
    input btnC,           // Reset
    output [3:0] an,      // 7-segment anodes
    output [6:0] seg      // 7-segment segments
);

    // Split switches into A and B
    wire [3:0] A = sw[3:0];
    wire [3:0] B = sw[7:4];

    // Clock divider output
    wire slow_clk;

    // Anode signals from scanner
    wire [3:0] anode_out;

    // Select signal
    reg select;

    // Math result
    wire [7:0] result;

    // Current digit to display
    reg [3:0] current_digit;

    // 7-segment decoder output
    wire [6:0] segments_out;

    // ----------------------------
    // Instantiate Clock Divider
    // ----------------------------
    clock_div #(.DIVIDE_BY(DIVIDE_BY)) div_inst (
        .clock(clk),
        .reset(btnC),
        .div_clock(slow_clk)
    );

    // ----------------------------
    // Instantiate Scanner
    // ----------------------------
    seven_seg_scanner scanner_inst (
        .div_clock(slow_clk),
        .reset(btnC),
        .anode(anode_out)
    );

    // Connect scanner output to anodes
    assign an = anode_out;

    // ----------------------------
    // Instantiate Math Block
    // ----------------------------
    math_block math_inst (
        .A(A),
        .B(B),
        .select(select),
        .result(result)
    );

    // ----------------------------
    // Instantiate 7-Segment Decoder
    // ----------------------------
    seven_seg_decoder decoder_inst (
        .digit(current_digit),
        .segments(segments_out)
    );

    // Connect segments output
    assign seg = segments_out;

    // ----------------------------
    // Update select and current_digit based on anode state
    // Use flip-flops driven by slow_clk
    // ----------------------------
    always @(posedge slow_clk or posedge btnC) begin
        if (btnC) begin
            select <= 0;
            current_digit <= 4'b0000;
        end else begin
            case (anode_out)
                4'b1110: begin // Digit 0: show A
                    select <= 0;
                    current_digit <= A;
                end
                4'b1101: begin // Digit 1: show B
                    select <= 0;
                    current_digit <= B;
                end
                4'b1011: begin // Digit 2: show A + B
                    select <= 0;
                    current_digit <= result[3:0];
                end
                4'b0111: begin // Digit 3: show A - B
                    select <= 1;
                    current_digit <= result[3:0];
                end
                default: begin
                    select <= 0;
                    current_digit <= 4'b0000;
                end
            endcase
        end
    end

endmodule
